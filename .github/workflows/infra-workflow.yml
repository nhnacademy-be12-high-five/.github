name: Infra 공용 배포

on:
  workflow_call:
    inputs:
      service-name:
        required: true
        type: string
        description: "docker-compose.yml에 정의된 기본 서비스 이름 (예: front_server, eureka_server)"
      # [추가됨] 다중 인스턴스(_1, _2)로 배포되는 서비스인지 여부
      is-multi-instance:
        required: false
        type: boolean
        default: false
        description: "true일 경우 _1, _2를 붙여서 순차 배포합니다. (기본값: false)"
      container-name:
        required: false # 필수에서 선택으로 변경 (더 이상 스크립트에서 사용 안 함)
        type: string
        description: "(사용되지 않음) 이전 버전 호환성을 위해 유지"
      compose-file:
        required: false
        type: string
        default: "docker-compose.yml"
        description: "사용할 docker-compose 파일명"

    secrets:
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true
      SSH_IP:
        required: true
      SSH_ID:
        required: true
      SSH_PW:
        required: true
      SSH_PORT:
        required: true

jobs:
  deploy-infra:
    runs-on: ubuntu-latest

    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4

      - name: JDK 21 설정
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      # 인프라 서비스는 테스트 없이 빌드만 수행
      - name: Maven 빌드
        run: mvn clean package -DskipTests

      - name: Docker 로그인
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Docker 이미지 빌드 및 푸시
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          # 이미지 태그는 입력받은 service-name을 사용
          tags: ${{ secrets.DOCKER_USERNAME }}/${{ inputs.service-name }}:latest

      - name: 서버에 배포
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_IP }}
          username: ${{ secrets.SSH_ID }}
          password: ${{ secrets.SSH_PW }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            echo "🚀 ${{ inputs.service-name }} 배포 시작..."
            cd ~/www/nhnbook
            
            SERVICE_NAME="${{ inputs.service-name }}"
            COMPOSE_FILE="${{ inputs.compose-file }}"
            IS_MULTI_INSTANCE="${{ inputs.is-multi-instance }}"
            
            # -----------------------------------------------------------
            # 1. 배포 로직 (Front는 다중, 나머지는 단일)
            # -----------------------------------------------------------
            if [ "$IS_MULTI_INSTANCE" = "true" ]; then
              echo "ℹ️ 다중 인스턴스 배포 모드 (Front Server)"
              for i in 1 2; do
                TARGET="${SERVICE_NAME}-${i}" 
                # docker-compose 이름 규칙에 맞춤 (front-server-1)
            
                echo "🔄 $TARGET 배포 중..."
                docker compose -f $COMPOSE_FILE pull $TARGET
                docker compose -f $COMPOSE_FILE up -d $TARGET
                sleep 10
              done
            else
              echo "ℹ️ 단일 인스턴스 배포 모드 (Gateway/Config/Eureka)"
              docker compose -f $COMPOSE_FILE pull $SERVICE_NAME
              docker compose -f $COMPOSE_FILE up -d $SERVICE_NAME
            fi
            
            # -----------------------------------------------------------
            # 2. 헬스 체크 포트 설정 (Host 포트 기준)
            # -----------------------------------------------------------
            # 여기가 핵심입니다. 각 서비스가 Host에 노출하는 포트를 지정합니다.
            
            CHECK_PORT=8080 # 기본값
            
            case "$SERVICE_NAME" in
              "eureka-server"|"eureka_server") CHECK_PORT=10481 ;;
              "config-server"|"config_server") CHECK_PORT=10482 ;; # 8888 -> 10482
              "gateway-server"|"gateway_server") CHECK_PORT=10485 ;; # 8000 -> 10485 (핵심!)
              "front-server"|"front_server") CHECK_PORT=10483 ;;   # front-1 기준
            esac
            
            echo "🏥 헬스 체크 시작 (Service: $SERVICE_NAME, Host Port: $CHECK_PORT)..."
            HEALTHY=false
            
            # Gateway는 Config Server 연결 때문에 부팅이 오래 걸릴 수 있음 (최대 30회/150초 대기)
            for i in {1..30}; do
              # Host(Ubuntu)에서 curl을 날리므로 127.0.0.1은 Host 자신을 의미함
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:$CHECK_PORT/actuator/health || echo "000")
            
              # 200 OK면 성공
              if [ "$STATUS" == "200" ]; then
                HEALTHY=true
                echo "✅ [$i/30] 상태 정상 (Code: 200)"
                break
              fi
            
              # Front Server는 Actuator가 없어서 404가 뜨더라도 연결 자체가 되면 성공으로 간주
              if [[ "$SERVICE_NAME" == *"front"* ]] && [ "$STATUS" != "000" ]; then
                 HEALTHY=true
                 echo "✅ [$i/30] 서버 응답 확인됨 (Code: $STATUS)"
                 break
              fi
            
              echo "⏳ [$i/30] 부팅 대기 중... (Code: $STATUS)"
              sleep 5
            done
            
            if [ "$HEALTHY" != true ]; then
              echo "❌ 배포 실패: 헬스 체크 타임아웃 (Port: $CHECK_PORT)"
              echo "📋 컨테이너 로그 확인:"
            
              # 실패 시 로그 출력 (다중/단일 구분)
              if [ "$IS_MULTI_INSTANCE" = "true" ]; then
                 docker logs --tail 50 "team5-${SERVICE_NAME}-1"
              else
                 docker logs --tail 50 "team5-${SERVICE_NAME}"
              fi
              exit 1
            fi
            
            docker image prune -f
            echo "🎉 $SERVICE_NAME 배포 완료!"